# Bug Fixing Guide for SqlScriptDOM

This guide provides a summary of the typical workflow for fixing a bug in the SqlScriptDOM parser, based on practical experience. For a more comprehensive overview of the project structure and code generation, please refer to the main [Copilot / AI instructions for SqlScriptDOM](../copilot-instructions.md).

## Before You Start: Identify the Bug Type

**IMPORTANT**: Not all bugs require grammar changes. Determine which type of fix you need:

1. **Validation Issues**: Syntax is already parseable but incorrectly rejected
   - Error: "Option 'X' is not valid..." or "Feature 'Y' not supported..."
   - Example: ALTER TABLE RESUMABLE works in ALTER INDEX but not ALTER TABLE
   - **→ Use [Validation_fix.guidelines.instructions.md](Validation_fix.guidelines.instructions.md) instead of this guide**

2. **Grammar Issues**: Parser doesn't recognize the syntax at all (THIS guide)
   - Error: "Incorrect syntax near..." or "Unexpected token..."
   - Example: Adding new keywords, operators, or statement types
   - **→ Continue with this guide**

3. **Predicate Recognition**: Identifier predicates fail with parentheses
   - Error: `WHERE REGEXP_LIKE(...)` works but `WHERE (REGEXP_LIKE(...))` fails
   - **→ Use [parser.guidelines.instructions.md](parser.guidelines.instructions.md)**

## Summary of the Bug-Fixing Workflow

The process of fixing a bug, especially one that involves adding new syntax, follows these general steps:

1.  **Grammar Modification**:
    *   Identify the correct grammar rule to modify in the `SqlScriptDom/Parser/TSql/*.g` files.
    *   Apply the necessary changes to all relevant `.g` files, from the version where the syntax was introduced up to the latest version (e.g., `TSql130.g` through `TSql170.g` and `TSqlFabricDW.g`).

2.  **Abstract Syntax Tree (AST) Update**:
    *   If the new syntax requires a new AST node or enum member, edit `SqlScriptDom/Parser/TSql/Ast.xml`. For example, adding a new operator like `NOT LIKE` required adding a `NotLike` member to the `BooleanComparisonType` enum.

3.  **Script Generation Update**:
    *   Update the script generator to handle the new AST node or enum. This typically involves modifying files in `SqlScriptDom/ScriptDom/SqlServer/ScriptGenerator/`. For the `NOT LIKE` example, this meant adding an entry to the `_booleanComparisonTypeGenerators` dictionary in `SqlScriptGeneratorVisitor.CommonPhrases.cs`.

5.  **Build the Project**:
    *   After making code changes, run a build to regenerate the parser and ensure everything compiles correctly:
        ```bash
        dotnet build
        ```

6.  **Add a Unit Test**:
    *   Create a new `.sql` file in `Test/SqlDom/TestScripts/` that contains the specific syntax for the new test case.

7.  **Define the Test Case**:
    *   Add a new `ParserTest` entry to the appropriate `Only<version>SyntaxTests.cs` files (e.g., `Only130SyntaxTests.cs`). This entry points to your new test script and defines the expected number of parsing errors for each SQL Server version.

8.  **Generate and Verify Baselines**:
    This is a critical and multi-step process:
    *   **a. Create Placeholder Baseline Files**: Before running the test, create empty or placeholder baseline files in the corresponding `Test/SqlDom/Baselines<version>/` directories. The filename must match the test script's filename.
    *   **b. Run the Test to Get the Generated Script**: Run the specific test that you just added. It is *expected to fail* because the placeholder baseline will not match the script generated by the parser.
        ```bash
        # Example filter for running a specific test
        dotnet test --filter "FullyQualifiedName~YourTestMethodName"
        ```
    *   **c. Update the Baseline Files**: Copy the "Actual" output from the test failure log. This is the correctly formatted script generated from the AST. Paste this content into all the baseline files you created in step 8a.
    *   **d. Re-run the Tests**: Run the same test command again. This time, the tests should pass, confirming that the generated script matches the new baseline.

    **Practical Example - Baseline Generation Workflow**:
    ```bash
    # 1. Create test script
    echo "ALTER TABLE t ADD CONSTRAINT pk PRIMARY KEY (id) WITH (RESUMABLE = ON);" > Test/SqlDom/TestScripts/AlterTableResumableTests160.sql
    
    # 2. Create empty baseline
    touch Test/SqlDom/Baselines160/AlterTableResumableTests160.sql
    
    # 3. Add test entry to Only160SyntaxTests.cs:
    # new ParserTest160("AlterTableResumableTests160.sql", nErrors80: 1, ...),
    
    # 4. Run test (will fail, showing generated output)
    dotnet test --filter "AlterTableResumableTests" -c Debug
    
    # 5. Copy the "Actual" output from test failure into baseline file
    # Output looks like: "ALTER TABLE t ADD CONSTRAINT pk PRIMARY KEY (id) WITH (RESUMABLE = ON);"
    
    # 6. Re-run test (should pass now)
    dotnet test --filter "AlterTableResumableTests" -c Debug
    ```

9.  **⚠️ CRITICAL: Run Full Test Suite**:
    *   **Always run the complete test suite** to ensure your changes didn't break existing functionality:
        ```bash
        dotnet test Test/SqlDom/UTSqlScriptDom.csproj -c Debug
        ```
    *   **Why this is critical**: Grammar changes can have unintended side effects on other parts of the parser. Shared grammar rules are used in multiple contexts.
    *   **Common issues**: Modifying shared rules like `identifierColumnReferenceExpression` can cause other tests to fail because they now accept syntax that should be rejected.
    *   **Solution**: If tests fail, create context-specific grammar rules instead of modifying shared ones.

By following these steps, you can ensure that new syntax is correctly parsed, represented in the AST, generated back into a script, and fully validated by the testing framework without breaking existing functionality.

## Special Case: Extending Grammar Rules from Literals to Expressions

A common type of bug involves extending existing grammar rules that only accept literal values (like integers or strings) to accept full expressions (parameters, variables, outer references, etc.). This pattern was used to fix the VECTOR_SEARCH TOP_N parameter issue.

### Example: VECTOR_SEARCH TOP_N Parameter Extension

**Problem**: VECTOR_SEARCH's TOP_N parameter only accepted integer literals (`TOP_N = 10`) but needed to support parameters (`TOP_N = @k`) and outer references (`TOP_N = outerref.col`).

**Solution Steps**:

1. **Update AST Definition** (`SqlScriptDom/Parser/TSql/Ast.xml`):
   ```xml
   <!-- Before: -->
   <Member Name="TopN" Type="IntegerLiteral" Summary="..." />
   
   <!-- After: -->
   <Member Name="TopN" Type="ScalarExpression" Summary="..." />
   ```

2. **Update Grammar Rule** (`SqlScriptDom/Parser/TSql/TSql170.g`):
   ```antlr
   // Before - Variable declaration:
   IntegerLiteral vTopN;
   
   // After - Variable declaration:
   ScalarExpression vTopN;
   
   // Before - Parsing rule:
   vTopN = integer
   
   // After - Parsing rule: 
   vTopN = expression
   ```

3. **Script Generator**: Usually no changes needed if using `GenerateNameEqualsValue()` or similar generic methods that work with `TSqlFragment`.

4. **Test Cases**: Add tests covering the new expression types:
   ```sql
   -- Parameter test
   TOP_N = @k
   
   -- Outer reference test  
   TOP_N = outerref.max_results
   ```

### When to Apply This Pattern

Use this pattern when:
- ✅ Existing grammar accepts only literal values (integer, string, etc.)
- ✅ Users need to pass dynamic values (parameters, variables, computed expressions)
- ✅ The SQL Server syntax actually supports expressions in that position
- ✅ Backward compatibility must be maintained (literals still work)

### ⚠️ Critical Warning: Shared Grammar Rules

**DO NOT modify shared grammar rules** like `identifierColumnReferenceExpression` that are used throughout the codebase. This can cause:
- ✅ Other tests to fail unexpectedly
- ✅ Unintended syntax acceptance in different contexts
- ✅ Breaking changes in existing functionality

**Instead, create specialized rules** for your specific use case:
```antlr
// ❌ WRONG: Modifying shared rule
identifierColumnReferenceExpression: multiPartIdentifier[2] // Affects ALL usage

// ✅ CORRECT: Create specialized rule
vectorSearchColumnReferenceExpression: multiPartIdentifier[2] // Only for VECTOR_SEARCH
```

### Common Expression Types to Support

When extending from literals to expressions, consider supporting:
- **Parameters**: `@parameter`
- **Variables**: `@variable` 
- **Column references**: `table.column`
- **Outer references**: `outerref.column`
- **Function calls**: `FUNCTION(args)`
- **Arithmetic expressions**: `value + 1`
- **Case expressions**: `CASE WHEN ... END`

### Files Typically Modified

1. **`Ast.xml`**: Change member type from specific literal to `ScalarExpression`
2. **`TSql*.g`**: Update variable declarations and parsing rules
3. **Test files**: Add comprehensive test coverage
4. **Script generators**: Usually no changes needed for well-designed generators
By following these steps, you can ensure that new syntax is correctly parsed, represented in the AST, generated back into a script, and fully validated by the testing framework.

## Special Case: Parser Predicate Recognition Issues

If you encounter a bug where:
- An identifier-based predicate (like `REGEXP_LIKE`) works without parentheses: `WHERE REGEXP_LIKE('a', 'pattern')` ✅
- But fails with parentheses: `WHERE (REGEXP_LIKE('a', 'pattern'))` ❌
- The error is a syntax error near the closing parenthesis or semicolon

This is likely a **parser predicate recognition issue**. The grammar and AST are correct, but the `IsNextRuleBooleanParenthesis()` function doesn't recognize the identifier-based predicate.

**Solution**: Follow the [Parser Predicate Recognition Fix Guide](parser.guidelines.instructions.md) instead of the standard grammar modification workflow.

## Decision Tree: Which Guide to Use?

```
Start: You have a parsing bug
│
├─→ Error: "Option 'X' is not valid..." or "Feature not supported..."
│   └─→ Does similar syntax work elsewhere? (e.g., ALTER INDEX works)
│       └─→ YES: Use [Validation_fix.guidelines.instructions.md](Validation_fix.guidelines.instructions.md)
│
├─→ Error: "Incorrect syntax near..." or parser doesn't recognize syntax
│   └─→ Does the grammar need new rules or AST nodes?
│       └─→ YES: Use this guide (BUG_FIXING_GUIDE.md)
│
└─→ Error: Parentheses cause failure with identifier predicates
    └─→ Does `WHERE PREDICATE(...)` work but `WHERE (PREDICATE(...))` fail?
        └─→ YES: Use [parser.guidelines.instructions.md](parser.guidelines.instructions.md)
```

## Quick Reference: Fix Types by Symptom

| Symptom | Fix Type | Guide | Files Modified |
|---------|----------|-------|----------------|
| "Option 'X' is not valid in statement Y" | Validation | [Validation_fix.guidelines.instructions.md](Validation_fix.guidelines.instructions.md) | `TSql80ParserBaseInternal.cs` |
| "Incorrect syntax near keyword" | Grammar | This guide | `TSql*.g`, `Ast.xml`, Script generators |
| Parentheses break identifier predicates | Predicate Recognition | [parser.guidelines.instructions.md](parser.guidelines.instructions.md) | `TSql80ParserBaseInternal.cs` |
| Literal needs to become expression | Grammar Extension | [grammer.guidelines.instructions.md](grammer.guidelines.instructions.md) | `Ast.xml`, `TSql*.g` |

